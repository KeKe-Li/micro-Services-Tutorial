### micro-Services-Tutorial

 微服务最早由Martin Fowler与James Lewis于2014年共同提出，微服务架构风格是一种使用一套小服务来开发单个应用的方式途径，每个服务运行在自己的进程中，并使用轻量级机制通信，通常是HTTP API，这些服务基于业务能力构建，并能够通过自动化部署机制来独立部署，这些服务使用不同的编程语言实现，以及不同数据存储技术，并保持最低限度的集中式管理。然而微服务又需要限流器(Rate Limiter)，数据传输(Trasport 序列化和反序列化),日志(Logging),指标(Metrics)
,断路器(Circuit breaker),请求追踪(Request tracing ),服务发现(Service Discovery),因此就想写一篇关于微服务和微服务组件的总结来记录下自己使用优化的过程。

#### 常见安全算法

我们在开发的时候通常都会做签名加密或者验证，但是一直以来也没有做过总结，然后就准备利用这次的时间总结下这块的内容，常见的安全算法包括：MD5、SHA、DES、AES、RSA。接下来我们详细介绍下这块的内容。

常见的安全算法目录:

* [消息摘要算法](#消息摘要算法)
* [加密算法](#加密算法)
* [加密货币加密算法](#加密货币加密算法)


#### 消息摘要(Message Digest)

通常将长度不固定的消息（message)作为输入参数，运行特定的Hash函数，生成固定长度的输出，这个输出就是Hash，也称为这个消息的消息摘要（Message Digest）。

因为传统的checksum是弱校验，可以将一些位翻转校验出来，但是却无法校验出一些复杂的数据错误、人为制造的数据篡改。而使用Hash函数将原始属于作为输入参数，生成固定长度的消息摘要，MD5算法为128位，SHA-1为160位，附在原始数据的尾部，到达目的地，先将原始数据（message）与消息摘要（message digest）分离，然后运行同样的Hash算法，生成自己的消息摘要，比较两个消息摘要，相同则校验通过。

消息摘要算法的主要特征是加密过程不需要密钥，而且经过加密的数据无法被解密只有输入相同的明文数据经过相同的消息摘要算法才能得到相同的密文。

消息摘要算法主要应用在“数字签名”领域，作为对明文的摘要算法,其中最著名的摘要算法有RSA公司的MD5算法和SHA-1算法及其大量的变体。

消息摘要的特点是:

1. 消息摘要看起来是“伪随机的”,通常都是对相同的信息求摘要结果相同。
2. 即使消息稍微改变对生成的摘要影响也会很大。
3. 无论输入的消息有多长，计算出来的消息摘要的长度总是固定的。
4. 只能进行正向的信息摘要，而且无法从摘要中恢复出任何的消息，也找不到任何与原信息相关的信息。

消息摘要的应用:

1. 数据完整性检查（Data Integrity Check)

可以用于SSL/TLS/IPsec，将原始数据作为输入参数，生成Message Digest，然后用共享对称密钥加密，接收方做反向操作。

2. 数字证书签名 （ Digital Certification Signature）

可以将主机（服务器）的数字证书（明文）作为输入参数，生成Message Digest，然后用CA的私钥（Private Key）加密，这个Message Digest就变成了CA的数字签名，附在原始数字证书（明文）的末尾，成为一个整体，此整体即为CA签名的数字证书。

服务器与客户端认证时，将上文CA签名的数字证书发给客户端，客户端由于拥有CA的公钥（浏览器预装或手动安装），可以解密CA的数字签名，得到Message Digest，然后自己对数字证书运行相同的Hash算法，然后比较两个Message Digest，相同则认证通过。

3. 数据校验 （Checksum）

也用来将原始文件生成MD5 checksum，用户下载完文件，也计算一下下载文件的MD5 checksum，如果相同，则文件完好无缺。

4. 数据来源可靠性认证 （Authentication）

主要用于OSPF/ISIS/BGP，将原始数据和共享对称密钥作为共同输入参数，生成HMAC，接收方反向操作。



通常数字签名主要会用到非对称密钥加密技术与数字摘要技术。数字签名技术是将摘要信息用发送者的私钥加密，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比。 如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过。因此数字签名能够验证信息的完整性。 数字签名是个加密的过程，数字签名验证是个解密的过程。

#### 消息摘要算法：

* MD5

MD5消息摘要算法（MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。MD5由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于1992年公开，用以取代MD4算法。

MD5的作用通常是让大容量信息在用数字签名软件签署私人密钥前被"压缩"成一种保密的格式(把一个任意长度的字节串变换成一定长的十六进制数字串)。

MD5特点：

* 压缩性： 任意长度的数据，算出的MD5值长度都是固定的。
* 简易计算： 从原数据计算出MD5值很容易。
* 抗修改性： 对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。
* 强抗碰撞： 已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。

应用示例:
```go
package main

import (
	"crypto/md5"
	"fmt"
	"encoding/hex"
)

func main(){
	a := "1234567890"
	m := md5.New()
	//将a写入到m中
	m.Write([]byte(a))
	//m.Sum(nil)将m的hash转成[]byte格式
	n := m.Sum(nil)
	//输出加密结果
	v := hex.EncodeToString(n)
	fmt.Println("MD5: n",n)
	fmt.Println("MD5: v",v)
}
```
运行:

```go
MD5: n [232 7 241 252 248 45 19 47 155 176 24 202 103 56 161 159]
MD5: v e807f1fcf82d132f9bb018ca6738a19f
```
* SHA-1

SHA-1（Secure Hash Algorithm 1，中文名：安全散列算法1）是一种密码散列函数，美国国家安全局设计，并由美国国家标准技术研究所（NIST）发布为联邦数据处理标准（FIPS）。SHA-1可以生成一个被称为消息摘要的160位（20字节）散列值，散列值通常的呈现形式为40个十六进制数。

对于长度小于2^64位的消息，SHA1会产生一个160位(40个字符)的消息摘要。当接收到消息的时候，这个消息摘要可以用来验证数据的完整性。在传输的过程中，数据很可能会发生变化，那么这时候就会产生不同的消息摘要。

SHA-1特性：

* 它不可以从消息摘要中复原信息。
* 两个不同的消息不会产生同样的消息摘要,(但会有1x10 ^ 48分之一的机率出现相同的消息摘要,一般使用时忽略)。

应用示例:

```go
package main

import (
	"crypto/sha1"
	"fmt"
)

func main(){
	v := "I am use Golang"

	// 生成一个hash的模式是`sha1.New()`，`sha1.Write(bytes)`
	// 然后是`sha1.Sum([]byte{})`，下面我们开始一个新的hash
	h := sha1.New()

	// 写入要hash的字节，如果你的参数是字符串，使用`[]byte(s)`
	// 把它强制转换为字节数组
	h.Write([]byte(v))

	// 这里计算最终的hash值，Sum的参数是用来追加而外的字节到要
	// 计算的hash字节里面，一般来讲，如果上面已经把需要hash的
	// 字节都写入了，这里就设为nil就可以了
	n := h.Sum(nil)

	// SHA1散列值经常以16进制的方式输出，例如git commit就是
	// 这样，所以可以使用`%x`来将散列结果格式化为16进制的字符串
	fmt.Println(v)
	fmt.Printf("%x\n", n)
}
```
运行:

```go
I am use Golang
83b6dc2a15610e092f75a1a502a3ae00163a0239
```

* HMAC算法

密钥散列消息认证码（Keyed-hash message authentication code），又称散列消息认证码（Hash-based message authentication code，缩写为HMAC），是一种通过特别计算方式之后产生的消息认证码（MAC），使用密码散列函数，同时结合一个加密密钥。它可以用来保证数据的完整性，同时可以用来作某个消息的身份验证。

HMAC 是密钥相关的 哈希运算消息认证码（Hash-based Message Authentication Code），HMAC 运算利用 哈希算法 (MD5、SHA1 等)，以 一个密钥 和 一个消息 为输入，生成一个 消息摘要 作为 输出。
HMAC 发送方 和 接收方 都有的 key 进行计算，而没有这把 key 的第三方，则是 无法计算 出正确的 散列值的，这样就可以 防止数据被篡改。

应用示例:

```go
package main

import (
	"crypto/sha1"
	"crypto/hmac"
	"fmt"
)

func main(){
	key := []byte("I am use Golang")

	m := hmac.New(sha1.New,key)
	n := []byte("Gopher")
	m.Write(n)

	v := m.Sum(nil)
	fmt.Printf("%x\n",v)

}
```
运行:

```go
c68c8b2d6f7dc7355ee31e4f9c03dc2850995a53
```

#### 加密算法

数据加密的基本过程就是对原来为明文的文件或数据按某种算法进行处理，使其成为不可读的一段代码，通常称为“密文”，使其只能在输入相应的密钥之后才能显示出本来内容，通过这样的途径来达到保护数据不被非法人窃取、阅读的目的。 该过程的逆过程为解密，即将该编码信息转化为其原来数据的过程。

加密技术通常分为两大类：“对称式”和“非对称式”。

1. 对称式加密技术

对称式加密就是加密和解密使用同一个密钥，通常称之为“Session Key ”这种加密技术在当今被广泛采用，如美国政府所采用的DES加密标准就是一种典型的“对称式”加密法，它的Session Key长度为56bits。

常用的算法有：DES、3DES、AES等。

* DES

数据加密标准（Data Encryption Standard，缩写为 DES）是一种对称密钥加密块密码算法，1976年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），随后在国际上广泛流传开来。它基于使用56位密钥的对称算法。这个算法因为包含一些机密设计元素，相对短的密钥长度以及怀疑内含美国国家安全局（NSA）的后门而在开始时有争议，DES因此受到了强烈的学院派式的审查，并以此推动了现代的块密码及其密码分析的发展。

DES现在已经不是一种安全的加密方法，主要因为它使用的56位密钥过短。1999年1月，distributed.net与电子前哨基金会合作，在22小时15分钟内即公开破解了一个DES密钥。也有一些分析报告提出了该算法的理论上的弱点，虽然在实际中难以应用。为了提供实用所需的安全性，可以使用DES的派生算法3DES来进行加密，虽然3DES也存在理论上的攻击方法。在2001年，DES作为一个标准已经被高级加密标准（AES）所取代。另外，DES已经不再作为国家标准科技协会（前国家标准局）的一个标准。

* 3DES

3DES（或称为Triple DES）是三重数据加密算法（TDEA，Triple Data Encryption Algorithm）块密码的通称。它相当于是对每个数据块应用三次DES加密算法。由于计算机运算能力的增强，原版DES密码的密钥长度变得容易被暴力破解；3DES即是设计用来提供一种相对简单的方法，即通过增加DES的密钥长度来避免类似的攻击，而不是设计一种全新的块密码算法。

3DES它使用3条56位的密钥对数据进行三次加密。数据加密标准（DES）是美国的一种由来已久的加密标准，它使用对称密钥加密法，并于1981年被ANSI组织规范为ANSI X.3.92。DES使用56位密钥和密码块的方法，而在密码块的方法中，文本被分成64位大小的文本块然后再进行加密。比起最初的DES，3DES更为安全。

* AES

高级加密标准（Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。

不同于它的前任标准DES，Rijndael使用的是代换-置换网络，而非Feistel架构。AES在软件及硬件上都能快速地加解密，相对来说较易于实作，且只需要很少的存储器。作为一个新的加密标准，目前正被部署应用到更广大的范围。

优缺点:

对称加密算法的优点是算法公开、计算量小、加密速度快、加密效率高。

对称加密算法的缺点是在数据传送前，发送方和接收方必须商定好秘钥，然后使双方都能保存好秘钥。其次如果一方的秘钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。

通常应用在保存用户手机号、身份证等敏感但能解密的信息等方面.

2. 非对称式加密技术

非对称式加密就是加密和解密所使用的不是同一个密钥，通常有两个密钥，称为“公钥”和“私钥”，它们两个必需配对使用，否则不能打开加密文件。这里的“公钥”是指可以对外公布的，“私钥”则不能，只能由持有人一个人知道。它的优越性就在这里，因为对称式的加密方法如果是在网络上传输加密文件就很难不把密钥告诉对方，不管用什么方法都有可能被别窃听到。而非对称式的加密方法有两个密钥，且其中的“公钥”是可以公开的，也就不怕别人知道，收件人解密时只要用自己的私钥即可以，这样就很好地避免了密钥的传输安全性问题。

常用的算法有：RSA、ECC等.

* RSA

RSA加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。RSA是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。

对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用RSA加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA钥匙才可能被强力方式解破。到目前为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的。

RSA加密算法是目前最有影响力的公钥加密算法，并且被普遍认为是目前最优秀的公钥方案 之一。RSA是第一个能同时用于加密和数字签名的算法，它能够抵抗到目前为止已知的所有密码攻击，已被ISO推荐为公钥数据加密标准。

RSA 加密算法 基于一个十分简单的数论事实：将两个大 素数 相乘十分容易，但想要对其乘积进行 因式分解 却极其困难，因此可以将 乘积 公开作为 加密密钥。

* ECC

椭圆曲线密码学（Elliptic curve cryptography，缩写为 ECC）是一种建立公开密钥加密的演算法，最初由Koblitz和Miller两人于1985年提出，其数学基础是利用椭圆曲线上的有理点构成Abel加法群上椭圆离散对数的计算困难性。公钥密码体制根据其所依据的难题一般分为三类：大整数分解问题类、离散对数问题类、椭圆曲线类。有时也把椭圆曲线类归为离散对数类。

ECC的主要优势是在某些情况下它比其他的方法使用更小的密钥——比如RSA加密算法——提供相当的或更高等级的安全。ECC的另一个优势是可以定义群之间的双线性映射，基于Weil对或是Tate对；双线性映射已经在密码学中发现了大量的应用，例如基于身份的加密。不过一个缺点是加密和解密操作的实现比其他机制花费的时间长。

优缺点:

非对称加密与对称加密相比，其安全性更好：对称加密的通信双方使用相同的秘钥，如果一方的秘钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对秘钥，一个用来加密，一个用来解密，而且公钥是公开的，秘钥是自己保存的，不需要像对称加密那样在通信之前要先同步秘钥。

非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。

非对称加密算法一般用于签名和认证。


#### 加密货币加密算法

根据现有加密货币整理的加密算法如下:

1. SHA-256：Bitcoins、Peercoin、Namecoin
2. scrypt：Litecoins、Feathercoin、Novacoin、Dogecoin
3. scrypt-cacha：Yacoin、Ethereum Classic
4. ETHASH：Ethereum
5. ECDSA：Ripple
6. X11：DASH

* SHA-256

安全散列算法（Secure Hash Algorithm，缩写为 SHA）是一个密码散列函数家族，是 FIPS 所认证的安全散列算法。能计算出一个数字消息所对应到的，长度固定的字符串（又称消息摘要）的算法。且若输入的消息不同，它们对应到不同字符串的机率很高。

SHA 家族包含 SHA-0、SHA-1、SHA-2、SHA-3，由于比特币白皮书 2008 年才发布，彼时 SHA-3 还未问世，所以比特币采用的是 SHA-2 家族的 SHA-256 加密算法。

SHA-256 算法使用了一组6个逻辑函数及一组常数KT, 采用512比特的消息块，每一个消息块 Xi 分成 16 个 32 比特的字 M0, M1…M15。Hash 函数的安全性很大程度上取决于抗强碰撞的能力，即攻击者找出两个涓息 M 和 MtM≠Mt，使得 H(M)=HMt , 因此，评价一个 Hash 函数的安全性，就是看攻击者在现有的条件下，是否可以找到该函数的一对碰撞。目前已有的对 Hash 函数攻击的方法包括生日攻击、彩虹表攻击、差分攻击等。

* scrypt

scrypt 是由著名的 FreeBSD 黑客 Colin Percival 为他的备份服务 Tarsnap 开发的。刚开始只是用于防止网络攻击用的，但是后来逐渐延用到虚拟货币的技术上。

scrypt 加密算法不仅计算所需时间长，而且占用的内存也多，使得并行计算多个摘要异常困难，因此利用 rainbow table 进行暴力攻击更加困难。scrypt 没有在生产环境中大规模应用，并且缺乏仔细的审察和广泛的函数库支持。但是，scrypt 在算法层面只要没有破绽，它的安全性应该高于 PBKDF2 和 bcrypt。并且以特币将 scrypt 算法用于挖矿算法中，将 scrypt 算法的优势充分发挥出来。

* ETHASH

Ethash（之前被称为 Dagger-Hashimoto），是基于一个大的、瞬时的、任意生成的、形成 DAG（Dagger-part）的资料组规定，尝试解决它一个特定的约束，部分通过区块标题散列来决定。

它被设计用于在一个只有慢 CPU 的环境中来散列快速验证时间，但在被提供大量高带宽内存时，为挖矿提供大量的加速。大量内存需求意味着大规模矿工获得相对少的超线性利益。高带宽需求意味着从堆在很多超速处理单元、分享同样内存的加速在每个单独的单元给出很少的利益。

* ECDSA

椭圆曲线数字签名算法（ECDSA）是使用椭圆曲线密码（ECC）对数字签名算法（DSA）的模拟。ECDSA 于 1999 年成为 ANSI 标准，并于 2000 年成为 IEEE 和 NIST 标准。它在 1998 年既已为 ISO 所接受，并且包含它的其他一些标准亦在 ISO 的考虑之中。与普通的离散对数问题（discrete logarithm problem DLP）和大数分解问题（integer factorization problem IFP）不同，椭圆曲线离散对数问题（elliptic curve discrete logarithm problem ECDLP）没有亚指数时间的解决方法。因此椭圆曲线密码的单位比特强度要高于其他公钥体制。

* X11

X11 是由达世币核心研发者 Evan Duffield 发明，并得到广泛应用的哈希算法。它的链式哈希算法运用了一系列共 11 个科学哈希算法，作为工作量证明。这样不仅确保了信息处理分配的公正，还保留了比特币原有的特性。不过，与之适配的专用集成电路的制造难度更大，生产时间甚至长达数年。

借助链式哈希，高端 CPU 的平均转速达到了与 GPU 相似的水平。此外，这种算法的另一个好处是，与 Scrypt 相比，链式哈希算法下的 GPU 耗电量减少了 30%，温度降低了 30–50%。

X11 是一种链式工作量证明 (PoW) 算法。2014 年 1 月 18 日，它被首次应用在暗黑币上。这种算法受到 Quark 链式哈希算法的启发，在其基础上进行了深度和复杂度的拓展。此外，它与 Quark 算法的不同点在于：X11 哈希算法的回合数量是预先确定的，而不是像 Quark 那样随机选定。

X11 采用了 11 轮哈希算法，包括 blake, bmw, groestl, jh, keccak, skein, luffa, cubehash, shavite, simd 和 echo。这使得它成为现代加密数字货币中最安全和最复杂的算法之一。

X11 的优势在于：

* 增强货币的隐秘性和安全性
* 专用集成电路阻力
* 机枪池阻力
* 均衡发展的 CPU 和 GPU 挖矿
* 减少图形处理器能耗和热量输出

对于个人而言，需要了解的是，密码越复杂，被破解的难度越高，概率越低。然后在使用的过程中发送信息就越安全。
