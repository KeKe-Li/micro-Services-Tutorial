### micro-Services-Tutorial

 微服务最早由Martin Fowler与James Lewis于2014年共同提出，微服务架构风格是一种使用一套小服务来开发单个应用的方式途径，每个服务运行在自己的进程中，并使用轻量级机制通信，通常是HTTP API，这些服务基于业务能力构建，并能够通过自动化部署机制来独立部署，这些服务使用不同的编程语言实现，以及不同数据存储技术，并保持最低限度的集中式管理。然而微服务又需要限流器(Rate Limiter)，数据传输(Trasport 序列化和反序列化),日志(Logging),指标(Metrics)
,断路器(Circuit breaker),请求追踪(Request tracing ),服务发现(Service Discovery),因此就想写一篇关于微服务和微服务组件的总结来记录下自己使用优化的过程．

#### 常见安全算法

我们在开发的时候通常都会做签名加密或者验证，但是一直以来也没有做过总结，然后就准备利用这次的时间总结下这块的内容，常见的安全算法包括：MD5、SHA、DES、AES、RSA。接下来我们详细介绍下这块的内容。

我们先从消息摘要算法说起。

#### 消息摘要(Message Digest)

通常将长度不固定的消息（message)作为输入参数，运行特定的Hash函数，生成固定长度的输出，这个输出就是Hash，也称为这个消息的消息摘要（Message Digest）。

因为传统的checksum是弱校验，可以将一些位翻转校验出来，但是却无法校验出一些复杂的数据错误、人为制造的数据篡改。而使用Hash函数将原始属于作为输入参数，生成固定长度的消息摘要，MD5算法为128位，SHA-1为160位，附在原始数据的尾部，到达目的地，先将原始数据（message）与消息摘要（message digest）分离，然后运行同样的Hash算法，生成自己的消息摘要，比较两个消息摘要，相同则校验通过。

消息摘要算法的主要特征是加密过程不需要密钥，而且经过加密的数据无法被解密只有输入相同的明文数据经过相同的消息摘要算法才能得到相同的密文。

消息摘要算法主要应用在“数字签名”领域，作为对明文的摘要算法,其中最著名的摘要算法有RSA公司的MD5算法和SHA-1算法及其大量的变体。

消息摘要的特点是:

1. 消息摘要看起来是“伪随机的”,通常都是对相同的信息求摘要结果相同。
2. 即使消息稍微改变对生成的摘要影响也会很大。
3. 无论输入的消息有多长，计算出来的消息摘要的长度总是固定的。
4. 只能进行正向的信息摘要，而且无法从摘要中恢复出任何的消息，也找不到任何与原信息相关的信息。

消息摘要的应用:

1. 数据完整性检查（Data Integrity Check)

可以用于SSL/TLS/IPsec，将原始数据作为输入参数，生成Message Digest，然后用共享对称密钥加密，接收方做反向操作。

2. 数字证书签名 （ Digital Certification Signature）

可以将主机（服务器）的数字证书（明文）作为输入参数，生成Message Digest，然后用CA的私钥（Private Key）加密，这个Message Digest就变成了CA的数字签名，附在原始数字证书（明文）的末尾，成为一个整体，此整体即为CA签名的数字证书。

服务器与客户端认证时，将上文CA签名的数字证书发给客户端，客户端由于拥有CA的公钥（浏览器预装或手动安装），可以解密CA的数字签名，得到Message Digest，然后自己对数字证书运行相同的Hash算法，然后比较两个Message Digest，相同则认证通过。

3. 数据校验 （Checksum）

也用来将原始文件生成MD5 checksum，用户下载完文件，也计算一下下载文件的MD5 checksum，如果相同，则文件完好无缺。

4. 数据来源可靠性认证 （Authentication）

主要用于OSPF/ISIS/BGP，将原始数据和共享对称密钥作为共同输入参数，生成HMAC，接收方反向操作。



通常数字签名主要会用到非对称密钥加密技术与数字摘要技术。数字签名技术是将摘要信息用发送者的私钥加密，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比。 如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过。因此数字签名能够验证信息的完整性。 数字签名是个加密的过程，数字签名验证是个解密的过程。


#### 常见消息摘要算法：

* MD5

MD5消息摘要算法（MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。MD5由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于1992年公开，用以取代MD4算法。

MD5的作用通常是让大容量信息在用数字签名软件签署私人密钥前被"压缩"成一种保密的格式(把一个任意长度的字节串变换成一定长的十六进制数字串)。

MD5特点：
* 压缩性： 任意长度的数据，算出的MD5值长度都是固定的。
* 简易计算： 从原数据计算出MD5值很容易。
* 抗修改性： 对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。
* 强抗碰撞： 已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。

应用示例:
```go
package main

import (
	"crypto/md5"
	"fmt"
	"encoding/hex"
)

func main(){
	a := "1234567890"
	m := md5.New()
	//将a写入到m中
	m.Write([]byte(a))
	//m.Sum(nil)将m的hash转成[]byte格式
	n := m.Sum(nil)
	//输出加密结果
	v := hex.EncodeToString(n)
	fmt.Println("MD5: n",n)
	fmt.Println("MD5: v",v)
}
```
运行:
```go
MD5: n [232 7 241 252 248 45 19 47 155 176 24 202 103 56 161 159]
MD5: v e807f1fcf82d132f9bb018ca6738a19f
```
* SHA-1

SHA-1（Secure Hash Algorithm 1，中文名：安全散列算法1）是一种密码散列函数，美国国家安全局设计，并由美国国家标准技术研究所（NIST）发布为联邦数据处理标准（FIPS）。SHA-1可以生成一个被称为消息摘要的160位（20字节）散列值，散列值通常的呈现形式为40个十六进制数。

对于长度小于2^64位的消息，SHA1会产生一个160位(40个字符)的消息摘要。当接收到消息的时候，这个消息摘要可以用来验证数据的完整性。在传输的过程中，数据很可能会发生变化，那么这时候就会产生不同的消息摘要。

SHA-1特性：

* 它不可以从消息摘要中复原信息。
* 两个不同的消息不会产生同样的消息摘要,(但会有1x10 ^ 48分之一的机率出现相同的消息摘要,一般使用时忽略)。

应用示例:
```go
package main

import (
	"crypto/sha1"
	"fmt"
)

func main(){
	v := "I am use Golang"

	// 生成一个hash的模式是`sha1.New()`，`sha1.Write(bytes)`
	// 然后是`sha1.Sum([]byte{})`，下面我们开始一个新的hash
	h := sha1.New()

	// 写入要hash的字节，如果你的参数是字符串，使用`[]byte(s)`
	// 把它强制转换为字节数组
	h.Write([]byte(v))

	// 这里计算最终的hash值，Sum的参数是用来追加而外的字节到要
	// 计算的hash字节里面，一般来讲，如果上面已经把需要hash的
	// 字节都写入了，这里就设为nil就可以了
	n := h.Sum(nil)

	// SHA1散列值经常以16进制的方式输出，例如git commit就是
	// 这样，所以可以使用`%x`来将散列结果格式化为16进制的字符串
	fmt.Println(v)
	fmt.Printf("%x\n", n)
}
```
运行:
```go
I am use Golang
83b6dc2a15610e092f75a1a502a3ae00163a0239
```
#### 加密算法


